-- Apaga todas as tabelas do seu schema, respeitando FKs, e reseta IDs
TRUNCATE tb_review,
         tb_evaluation,
         tb_articles_users,
         tb_article,
         tb_user_role,
         tb_user,
         tb_congresso,
         tb_role,
         tb_card,
         tb_address
RESTART IDENTITY CASCADE;

DROP TABLE IF EXISTS
    tb_review,
    tb_evaluation,
    tb_articles_users,
    tb_article,
    tb_user_role,
    tb_user,
    tb_congresso,
    tb_role,
    tb_card,
    tb_address
CASCADE;


-- tb_address
CREATE TABLE tb_address (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    city        VARCHAR(255),
    complement  VARCHAR(255),
    country     VARCHAR(255),
    number      VARCHAR(255),
    state       VARCHAR(255),
    street      VARCHAR(255),
    zip_code    VARCHAR(255)
);

-- tb_article
CREATE TABLE tb_article (
    congresso_id BIGINT,
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    published_at TIMESTAMPTZ(6),
    description  VARCHAR(255),
    format       VARCHAR(255) CHECK (format IN ('PDF')),
    status       VARCHAR(255) CHECK (status IN ('PENDING','VALID','EXPIRED')),
    title        VARCHAR(255),
    body         TEXT   -- CLOB → TEXT em PostgreSQL
);

-- tb_articles_users
CREATE TABLE tb_articles_users (
    article_id BIGINT NOT NULL,
    user_id    BIGINT NOT NULL,
    PRIMARY KEY (article_id, user_id)
);

-- tb_card
CREATE TABLE tb_card (
    cvv INTEGER,
    expired DATE,
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    number VARCHAR(255)
);

-- tb_congresso
CREATE TABLE tb_congresso (
    max_reviews_per_article INTEGER,
    min_reviews_per_article INTEGER,
    end_date          TIMESTAMP(6),
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    review_deadline   TIMESTAMP(6),
    start_date        TIMESTAMP(6),
    submission_deadline TIMESTAMP(6),
    congresso_modality VARCHAR(255) CHECK (congresso_modality IN ('ONLINE','IN_PERSON','HYBRID')),
    description       VARCHAR(255),
    description_title VARCHAR(255),
    image_thumbnail   BYTEA,   -- varbinary → bytea
    name              VARCHAR(255),
    place             VARCHAR(255)
);

-- tb_evaluation
CREATE TABLE tb_evaluation (
    final_score       DOUBLE PRECISION,
    number_of_reviews INTEGER,
    article_id BIGINT NOT NULL UNIQUE,
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
);

-- tb_review
CREATE TABLE tb_review (
    score INTEGER,
    article_id BIGINT,
    create_at TIMESTAMP(6),
    evaluation_id BIGINT,
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    reviewer_id BIGINT NOT NULL,
    comment VARCHAR(255)
);

-- tb_role
CREATE TABLE tb_role (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    authority VARCHAR(255)
);

-- tb_user
CREATE TABLE tb_user (
    is_reviewer BOOLEAN,
    address_id BIGINT NOT NULL UNIQUE,
    card_id BIGINT NOT NULL UNIQUE,
    congresso_id BIGINT,
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    membership_number UUID NOT NULL UNIQUE,
    login VARCHAR(255) UNIQUE,
    password VARCHAR(255),
    username_user VARCHAR(255),
    work_place VARCHAR(255),
    profile_image BYTEA  -- BLOB → bytea
);

-- tb_user_role
CREATE TABLE tb_user_role (
    role_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    PRIMARY KEY (role_id, user_id)
);


-- Esses comandos garantem que o próximo INSERT use MAX(id) + 1 como novo valor.
SELECT setval(pg_get_serial_sequence('tb_address','id'),    COALESCE((SELECT MAX(id) FROM tb_address),0));
SELECT setval(pg_get_serial_sequence('tb_card','id'),       COALESCE((SELECT MAX(id) FROM tb_card),0));
SELECT setval(pg_get_serial_sequence('tb_role','id'),       COALESCE((SELECT MAX(id) FROM tb_role),0));
SELECT setval(pg_get_serial_sequence('tb_congresso','id'),  COALESCE((SELECT MAX(id) FROM tb_congresso),0));
SELECT setval(pg_get_serial_sequence('tb_user','id'),       COALESCE((SELECT MAX(id) FROM tb_user),0));
SELECT setval(pg_get_serial_sequence('tb_article','id'),    COALESCE((SELECT MAX(id) FROM tb_article),0));
SELECT setval(pg_get_serial_sequence('tb_evaluation','id'), COALESCE((SELECT MAX(id) FROM tb_evaluation),0));
SELECT setval(pg_get_serial_sequence('tb_review','id'),     COALESCE((SELECT MAX(id) FROM tb_review),0));

-- Tamanho total das tabelas
SELECT pg_size_pretty(
         SUM(pg_total_relation_size(oid))
       ) AS total_dataset
FROM pg_class
WHERE relname LIKE 'tb_%';

-- Tamanho por tabela (ordem decrescente)
SELECT relname AS tabela,
       pg_size_pretty(pg_total_relation_size(oid)) AS tamanho
FROM pg_class
WHERE relname LIKE 'tb_%'
ORDER BY pg_total_relation_size(oid) DESC;

-- Lista até 100 mil usuários com informações principais
SELECT id, username_user, login, work_place, is_reviewer
FROM tb_user
LIMIT 100000;

-- Lista até 100 mil artigos, mostrando título, status e um trecho dos 100 primeiros caracteres do corpo
SELECT id, title, status, LEFT(body, 100) AS snippet
FROM tb_article
LIMIT 100000;

-- Mostra a relação artigo → autores (usuários) para até 10 mil registros
-- Faz JOIN entre artigos, a tabela de ligação (tb_articles_users) e os usuários
SELECT a.id AS article_id, a.title, u.username_user
FROM tb_article a
JOIN tb_articles_users au ON a.id = au.article_id
JOIN tb_user u ON u.id = au.user_id
LIMIT 10000;

-- Lista até 10 mil reviews, incluindo nota (score), comentário e nome do revisor
-- Faz JOIN entre reviews e usuários (para pegar o nome do revisor)
SELECT r.id, r.article_id, r.score, r.comment, u.username_user AS reviewer
FROM tb_review r
JOIN tb_user u ON r.reviewer_id = u.id
LIMIT 10000;

-- Mostra até 10 mil avaliações finais de artigos
-- Inclui nota final consolidada e número de reviews considerados
SELECT e.id, e.article_id, e.final_score, e.number_of_reviews
FROM tb_evaluation e
LIMIT 10000;
